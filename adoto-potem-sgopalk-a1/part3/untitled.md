## Part 3

For part 3, the goal of part 3 was to create a program to take in a file that contains the entries of class members that describes their preferences for working on a group project. To begin solving this part of the assignment, I began by conceptualizing this problem as a local search problem. Mainly, this is due to the fact that the problem doesn't require or necessitate the recording the path taken to reach the goal, but rather finding the state that meets or gets close to the goal state. In this problem, the state space is all possible combinations of all members of the class in groups of at most three. The heuristic function for this part of the assignment was built-in to the challenge, in that the heuristic function was the amount of "complaint" emails, or the "total cost" reported in the program. 

My main inspiration for the approach in solving this problem was the lecture on local search and steepest descent in particular. I found this approach to be very useful for this rather interesting and challening part of the assignment. The first element of the program that I tackled was creating a function to parse the file. The key goal of interest was to find a way to store the member's preferences in a way that would be easily referenced in the cost function. Next was the function to create the initial state. This was interesting because I actually wrote two functions for this. The first was to take the list of class members and then shuffle them, and then to break them up into groups of three. This worked, but after discussing this strategy with my team, we decided to go with, in my view, a better solution which was to start all members in their own group. 

Once we made that decision, that informed the development of the successor function. This function returned all possible combinations of all the groups; essentially what happens is that it incrementally "builds" the groups as the solver function iterates. So all in all, our search solution starts with all members in their own group, then checks all successors with the cost function (which is the heuristic) and then replaces the current state with the successor state with the best value for the cost. We repeat this process and return results as it improves. Overall, it was an interesting challenge but a fun one as well!